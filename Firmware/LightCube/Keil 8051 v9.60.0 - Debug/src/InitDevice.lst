C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE INITDEVICE
OBJECT MODULE PLACED IN .\src\InitDevice.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5_2\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\src\tennp\g
                    -it\LightCube\Firmware\LightCube\src\InitDevice.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) 
                    -OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/SiliconLabs/SimplicityStudio/v5_2/developer/sdk
                    -s/8051/v4.3.1//Device/EFM8BB50/inc;C:/SiliconLabs/SimplicityStudio/v5_2/developer/sdks/8051/v4.3.1//Device/shared/si8051
                    -Base) PRINT(.\src\InitDevice.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\InitDevice.OBJ)

line level    source

   1          //=========================================================
   2          // src/InitDevice.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8BB50_Register_Enums.h>
  11          #include "InitDevice.h"
  12          
  13          // USER PROTOTYPES
  14          // USER FUNCTIONS
  15          
  16          // $[Library Includes]
  17          // [Library Includes]$
  18          
  19          //==============================================================================
  20          // enter_DefaultMode_from_RESET
  21          //==============================================================================
  22          extern void
  23          enter_DefaultMode_from_RESET (void)
  24          {
  25   1        // $[Config Calls]
  26   1        // Save the SFRPAGE
  27   1        uint8_t SFRPAGE_save = SFRPAGE;
  28   1        WDT_0_enter_DefaultMode_from_RESET ();
  29   1        PORTS_0_enter_DefaultMode_from_RESET ();
  30   1        PBCFG_0_enter_DefaultMode_from_RESET ();
  31   1        CLOCK_0_enter_DefaultMode_from_RESET ();
  32   1        CIP51_0_enter_DefaultMode_from_RESET ();
  33   1        ADC12_0_enter_DefaultMode_from_RESET ();
  34   1        TIMER16_2_enter_DefaultMode_from_RESET ();
  35   1        PCA_0_enter_DefaultMode_from_RESET ();
  36   1        PCACH_0_enter_DefaultMode_from_RESET ();
  37   1        INTERRUPT_0_enter_DefaultMode_from_RESET ();
  38   1        // Restore the SFRPAGE
  39   1        SFRPAGE = SFRPAGE_save;
  40   1        // [Config Calls]$
  41   1      
  42   1      }
  43          
  44          extern void
  45          WDT_0_enter_DefaultMode_from_RESET (void)
  46          {
  47   1        // $[Watchdog Timer Init Variable Declarations]
  48   1        uint32_t i;
  49   1        bool ea;
  50   1        // [Watchdog Timer Init Variable Declarations]$
  51   1      
  52   1        // $[WDTCN - Watchdog Timer Control]
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 2   

  53   1        SFRPAGE = 0x00;
  54   1      
  55   1        // Feed WDT timer before disabling (Erratum WDT_E102)
  56   1        WDTCN = 0xA5;
  57   1      
  58   1        // Add 2 LFO cycle delay before disabling WDT (Erratum WDT_E102)
  59   1        for (i = 0; i < (2 * 3062500UL) / (80000 * 3); i++)
  60   1          {
  61   2            NOP ();
  62   2          }
  63   1      
  64   1        // Disable WDT
  65   1        ea = IE_EA;
  66   1        IE_EA = 0;
  67   1        WDTCN = 0xDE;
  68   1        WDTCN = 0xAD;
  69   1        IE_EA = ea;
  70   1      
  71   1        // [WDTCN - Watchdog Timer Control]$
  72   1      
  73   1      }
  74          
  75          extern void
  76          PORTS_0_enter_DefaultMode_from_RESET (void)
  77          {
  78   1        // $[P0 - Port 0 Pin Latch]
  79   1        /***********************************************************************
  80   1         - P0.0 is high. Set P0.0 to drive or float high
  81   1         - P0.1 is low. Set P0.1 to drive low
  82   1         - P0.2 is high. Set P0.2 to drive or float high
  83   1         - P0.3 is high. Set P0.3 to drive or float high
  84   1         - P0.4 is low. Set P0.4 to drive low
  85   1         - P0.5 is low. Set P0.5 to drive low
  86   1         - P0.6 is high. Set P0.6 to drive or float high
  87   1         - P0.7 is low. Set P0.7 to drive low
  88   1         ***********************************************************************/
  89   1        P0 = P0_B0__HIGH | P0_B1__LOW | P0_B2__HIGH | P0_B3__HIGH | P0_B4__LOW
  90   1            | P0_B5__LOW | P0_B6__HIGH | P0_B7__LOW;
  91   1        // [P0 - Port 0 Pin Latch]$
  92   1      
  93   1        // $[P0MDOUT - Port 0 Output Mode]
  94   1        /***********************************************************************
  95   1         - P0.0 output is open-drain
  96   1         - P0.1 output is push-pull
  97   1         - P0.2 output is open-drain
  98   1         - P0.3 output is open-drain
  99   1         - P0.4 output is push-pull
 100   1         - P0.5 output is push-pull
 101   1         - P0.6 output is open-drain
 102   1         - P0.7 output is push-pull
 103   1         ***********************************************************************/
 104   1        P0MDOUT = P0MDOUT_B0__OPEN_DRAIN | P0MDOUT_B1__PUSH_PULL
 105   1            | P0MDOUT_B2__OPEN_DRAIN | P0MDOUT_B3__OPEN_DRAIN | P0MDOUT_B4__PUSH_PULL
 106   1            | P0MDOUT_B5__PUSH_PULL | P0MDOUT_B6__OPEN_DRAIN | P0MDOUT_B7__PUSH_PULL;
 107   1        // [P0MDOUT - Port 0 Output Mode]$
 108   1      
 109   1        // $[P0MDIN - Port 0 Input Mode]
 110   1        /***********************************************************************
 111   1         - P0.0 pin is configured for digital mode
 112   1         - P0.1 pin is configured for digital mode
 113   1         - P0.2 pin is configured for analog mode (should leave as digital to have pullup enabled)
 114   1         - P0.3 pin is configured for digital mode
 115   1         - P0.4 pin is configured for digital mode
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 3   

 116   1         - P0.5 pin is configured for digital mode
 117   1         - P0.6 pin is configured for digital mode
 118   1         - P0.7 pin is configured for digital mode
 119   1         ***********************************************************************/
 120   1        P0MDIN = P0MDIN_B0__DIGITAL | P0MDIN_B1__DIGITAL | P0MDIN_B2__DIGITAL
 121   1            | P0MDIN_B3__DIGITAL | P0MDIN_B4__DIGITAL | P0MDIN_B5__DIGITAL
 122   1            | P0MDIN_B6__DIGITAL | P0MDIN_B7__DIGITAL;
 123   1        // [P0MDIN - Port 0 Input Mode]$
 124   1      
 125   1        // $[P0SKIP - Port 0 Skip]
 126   1        /***********************************************************************
 127   1         - P0.0 pin is skipped by the crossbar
 128   1         - P0.1 pin is not skipped by the crossbar
 129   1         - P0.2 pin is skipped by the crossbar
 130   1         - P0.3 pin is skipped by the crossbar
 131   1         - P0.4 pin is not skipped by the crossbar
 132   1         - P0.5 pin is not skipped by the crossbar
 133   1         - P0.6 pin is skipped by the crossbar
 134   1         - P0.7 pin is not skipped by the crossbar
 135   1         ***********************************************************************/
 136   1        P0SKIP = P0SKIP_B0__SKIPPED | P0SKIP_B1__NOT_SKIPPED | P0SKIP_B2__SKIPPED
 137   1            | P0SKIP_B3__SKIPPED | P0SKIP_B4__NOT_SKIPPED | P0SKIP_B5__NOT_SKIPPED
 138   1            | P0SKIP_B6__SKIPPED | P0SKIP_B7__NOT_SKIPPED;
 139   1        // [P0SKIP - Port 0 Skip]$
 140   1      
 141   1        // $[P0MASK - Port 0 Mask]
 142   1        // [P0MASK - Port 0 Mask]$
 143   1      
 144   1        // $[P0MAT - Port 0 Match]
 145   1        // [P0MAT - Port 0 Match]$
 146   1      
 147   1      }
 148          
 149          extern void
 150          PBCFG_0_enter_DefaultMode_from_RESET (void)
 151          {
 152   1        // $[XBR2 - Port I/O Crossbar 2]
 153   1        /***********************************************************************
 154   1         - Weak Pullups enabled 
 155   1         - Crossbar enabled
 156   1         - PWM single ended output for all enabled channels
 157   1         - PWM0 Ch0, Ch1, and Ch2 routed to Port pin
 158   1         ***********************************************************************/
 159   1        XBR2 = XBR2_WEAKPUD__PULL_UPS_ENABLED | XBR2_XBARE__ENABLED
 160   1            | XBR2_PWMDE__SINGLE | XBR2_PWME__PWM0CH012;
 161   1        // [XBR2 - Port I/O Crossbar 2]$
 162   1      
 163   1        // $[PRTDRV - Port Drive Strength]
 164   1        /***********************************************************************
 165   1         - Coexistence enabled
 166   1         - All pins on P0 use high drive strength
 167   1         - All pins on P1 use high drive strength
 168   1         - All pins on P2 use high drive strength
 169   1         ***********************************************************************/
 170   1        PRTDRV = PRTDRV_COEX__ENABLED | PRTDRV_P0DRV__HIGH_DRIVE
 171   1            | PRTDRV_P1DRV__HIGH_DRIVE | PRTDRV_P2DRV__HIGH_DRIVE;
 172   1        // [PRTDRV - Port Drive Strength]$
 173   1      
 174   1        // $[XBR0 - Port I/O Crossbar 0]
 175   1        // [XBR0 - Port I/O Crossbar 0]$
 176   1      
 177   1        // $[XBR1 - Port I/O Crossbar 1]
 178   1        /***********************************************************************
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 4   

 179   1         - CEX0 routed to Port pin
 180   1         - ECI unavailable at Port pin
 181   1         - T0 unavailable at Port pin
 182   1         - T1 unavailable at Port pin
 183   1         - T2 unavailable at Port pin
 184   1         ***********************************************************************/
 185   1        XBR1 = XBR1_PCA0ME__CEX0 | XBR1_ECIE__DISABLED | XBR1_T0E__DISABLED
 186   1            | XBR1_T1E__DISABLED | XBR1_T2E__DISABLED;
 187   1        // [XBR1 - Port I/O Crossbar 1]$
 188   1      
 189   1      }
 190          
 191          extern void
 192          CLOCK_0_enter_DefaultMode_from_RESET (void)
 193          {
 194   1        // $[HFOSC0 49 and 49/1.5 MHz Oscillator Setup]
 195   1        // Ensure SYSCLK is > 24 MHz before switching to 49 MHz or 49/1.5 MHz Oscillator
 196   1        CLKSEL = CLKSEL_CLKSL__HFOSC0_clk24p5 | CLKSEL_CLKDIV__SYSCLK_DIV_1;
 197   1        while ((CLKSEL & CLKSEL_DIVRDY__BMASK) == CLKSEL_DIVRDY__NOT_READY)
 198   1          ;
 199   1        // [HFOSC0 49 and 49/1.5 MHz Oscillator Setup]$
 200   1      
 201   1        // $[CLKSEL - Clock Select]
 202   1        /***********************************************************************
 203   1         - Clock derived from the Internal High Frequency Oscillator 49 MHz
 204   1         - SYSCLK is equal to selected clock source divided by 1
 205   1         ***********************************************************************/
 206   1        CLKSEL = CLKSEL_CLKSL__HFOSC0_clk49 | CLKSEL_CLKDIV__SYSCLK_DIV_1;
 207   1        while ((CLKSEL & CLKSEL_DIVRDY__BMASK) == CLKSEL_DIVRDY__NOT_READY)
 208   1          ;
 209   1        // [CLKSEL - Clock Select]$
 210   1      
 211   1        // $[CLKGRP0 - Clock Group 0]
 212   1        /***********************************************************************
 213   1         - Select SYSCLK divided by CLKSEL.CLKDIV 
 214   1         - Divide selected clock group by 2
 215   1         - Disable charge pump refresh clock
 216   1         - Enable SAR clock
 217   1         ***********************************************************************/
 218   1        CLKGRP0 = CLKGRP0_CLKGRP0SL__SYSCLK | CLKGRP0_CLKDIVSL__DIV2
 219   1            | CLKGRP0_EN_CPCLK__DISABLE | CLKGRP0_EN_SARCLK__ENABLE;
 220   1        // [CLKGRP0 - Clock Group 0]$
 221   1      
 222   1      }
 223          
 224          extern void
 225          CIP51_0_enter_DefaultMode_from_RESET (void)
 226          {
 227   1        // $[PFE0CN - Prefetch Engine Control]
 228   1        /***********************************************************************
 229   1         - Enables the Prefetch Engine when SYSCLK < 50 MHz
 230   1         ***********************************************************************/
 231   1        SFRPAGE = 0x10;
 232   1        PFE0CN = PFE0CN_FLRT__SYSCLK_BELOW_50_MHZ;
 233   1        // [PFE0CN - Prefetch Engine Control]$
 234   1      
 235   1      }
 236          
 237          extern void
 238          INTERRUPT_0_enter_DefaultMode_from_RESET (void)
 239          {
 240   1        // $[EIE1 - Extended Interrupt Enable 1]
 241   1        /***********************************************************************
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 5   

 242   1         - Disable ADC0 Conversion Complete interrupt
 243   1         - Disable ADC0 Window Comparison interrupt
 244   1         - Disable all Port Match interrupts
 245   1         - Enable interrupt requests generated by PCA0
 246   1         - Disable all SMB0 interrupts
 247   1         - Disable Timer 3 interrupts
 248   1         ***********************************************************************/
 249   1        EIE1 = EIE1_EADC0__DISABLED | EIE1_EWADC0__DISABLED | EIE1_EMAT__DISABLED
 250   1            | EIE1_EPCA0__ENABLED | EIE1_ESMB0__DISABLED | EIE1_ET3__DISABLED;
 251   1        // [EIE1 - Extended Interrupt Enable 1]$
 252   1      
 253   1        // $[EIE2 - Extended Interrupt Enable 2]
 254   1        // [EIE2 - Extended Interrupt Enable 2]$
 255   1      
 256   1        // $[EIP1H - Extended Interrupt Priority 1 High]
 257   1        // [EIP1H - Extended Interrupt Priority 1 High]$
 258   1      
 259   1        // $[EIP1 - Extended Interrupt Priority 1 Low]
 260   1        // [EIP1 - Extended Interrupt Priority 1 Low]$
 261   1      
 262   1        // $[EIP2 - Extended Interrupt Priority 2]
 263   1        // [EIP2 - Extended Interrupt Priority 2]$
 264   1      
 265   1        // $[EIP2H - Extended Interrupt Priority 2 High]
 266   1        // [EIP2H - Extended Interrupt Priority 2 High]$
 267   1      
 268   1        // $[IE - Interrupt Enable]
 269   1        /***********************************************************************
 270   1         - Enable each interrupt according to its individual mask setting
 271   1         - Disable external interrupt 0
 272   1         - Disable external interrupt 1
 273   1         - Disable all SPI0 interrupts
 274   1         - Disable all Timer 0 interrupt
 275   1         - Disable all Timer 1 interrupt
 276   1         - Enable interrupt requests generated by the TF2L or TF2H flags
 277   1         - Disable UART0 interrupt
 278   1         ***********************************************************************/
 279   1        IE = IE_EA__ENABLED | IE_EX0__DISABLED | IE_EX1__DISABLED | IE_ESPI0__DISABLED
 280   1            | IE_ET0__DISABLED | IE_ET1__DISABLED | IE_ET2__ENABLED
 281   1            | IE_ES0__DISABLED;
 282   1        // [IE - Interrupt Enable]$
 283   1      
 284   1        // $[IP - Interrupt Priority]
 285   1        // [IP - Interrupt Priority]$
 286   1      
 287   1        // $[IPH - Interrupt Priority High]
 288   1        // [IPH - Interrupt Priority High]$
 289   1      
 290   1      }
 291          
 292          extern void
 293          PCA_0_enter_DefaultMode_from_RESET (void)
 294          {
 295   1        SFRPAGE = 0x00;
 296   1        // $[PCA Off]
 297   1        PCA0CN0_CR = PCA0CN0_CR__STOP;
 298   1        // [PCA Off]$
 299   1      
 300   1        // $[PCA0MD - PCA Mode]
 301   1        /***********************************************************************
 302   1         - PCA continues to function normally while the system controller is in
 303   1         Idle Mode
 304   1         - Disable the CF interrupt
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 6   

 305   1         - System clock
 306   1         ***********************************************************************/
 307   1        PCA0MD = PCA0MD_CIDL__NORMAL | PCA0MD_ECF__OVF_INT_DISABLED
 308   1            | PCA0MD_CPS__SYSCLK;
 309   1        // [PCA0MD - PCA Mode]$
 310   1      
 311   1        // $[PCA0CENT - PCA Center Alignment Enable]
 312   1        // [PCA0CENT - PCA Center Alignment Enable]$
 313   1      
 314   1        // $[PCA0L - PCA Counter/Timer Low Byte]
 315   1        // [PCA0L - PCA Counter/Timer Low Byte]$
 316   1      
 317   1        // $[PCA0H - PCA Counter/Timer High Byte]
 318   1        // [PCA0H - PCA Counter/Timer High Byte]$
 319   1      
 320   1        // $[PCA0POL - PCA Output Polarity]
 321   1        /***********************************************************************
 322   1         - Invert polarity
 323   1         - Use default polarity
 324   1         - Use default polarity
 325   1         ***********************************************************************/
 326   1        PCA0POL = PCA0POL_CEX0POL__INVERT | PCA0POL_CEX1POL__DEFAULT
 327   1            | PCA0POL_CEX2POL__DEFAULT;
 328   1        // [PCA0POL - PCA Output Polarity]$
 329   1      
 330   1        // $[PCA0PWM - PCA PWM Configuration]
 331   1        // [PCA0PWM - PCA PWM Configuration]$
 332   1      
 333   1        // $[PCA On]
 334   1        // [PCA On]$
 335   1      
 336   1      }
 337          
 338          extern void
 339          PCACH_0_enter_DefaultMode_from_RESET (void)
 340          {
 341   1        // $[PCA0 Settings Save]
 342   1        // Select Capture/Compare register)
 343   1        PCA0PWM &= ~PCA0PWM_ARSEL__BMASK;
 344   1        // [PCA0 Settings Save]$
 345   1      
 346   1        // $[PCA0CPM0 - PCA Channel 0 Capture/Compare Mode]
 347   1        /***********************************************************************
 348   1         - Disable negative edge capture
 349   1         - Enable a Capture/Compare Flag interrupt request when CCF0 is set
 350   1         - Enable match function
 351   1         - 16-bit PWM selected
 352   1         - Disable positive edge capture
 353   1         - Enable comparator function
 354   1         - Enable PWM function
 355   1         - Disable toggle function
 356   1         ***********************************************************************/
 357   1        PCA0CPM0 = PCA0CPM0_CAPN__DISABLED | PCA0CPM0_ECCF__ENABLED
 358   1            | PCA0CPM0_MAT__ENABLED | PCA0CPM0_PWM16__16_BIT | PCA0CPM0_CAPP__DISABLED
 359   1            | PCA0CPM0_ECOM__ENABLED | PCA0CPM0_PWM__ENABLED | PCA0CPM0_TOG__DISABLED;
 360   1        // [PCA0CPM0 - PCA Channel 0 Capture/Compare Mode]$
 361   1      
 362   1        // $[PCA0CPL0 - PCA Channel 0 Capture Module Low Byte]
 363   1        // [PCA0CPL0 - PCA Channel 0 Capture Module Low Byte]$
 364   1      
 365   1        // $[PCA0CPH0 - PCA Channel 0 Capture Module High Byte]
 366   1        PCA0CPH0 = 0x00;
 367   1        // [PCA0CPH0 - PCA Channel 0 Capture Module High Byte]$
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 7   

 368   1      
 369   1        // $[Auto-reload]
 370   1        // [Auto-reload]$
 371   1      
 372   1        // $[PCA0 Settings Restore]
 373   1        // [PCA0 Settings Restore]$
 374   1      
 375   1      }
 376          
 377          extern void
 378          ADC12_0_enter_DefaultMode_from_RESET (void)
 379          {
 380   1        // $[ADC0CN2 - ADC0 Control 2]
 381   1        // [ADC0CN2 - ADC0 Control 2]$
 382   1      
 383   1        // $[ADC0CN1 - ADC0 Control 1]
 384   1        /***********************************************************************
 385   1         - ADC0 operates in 10-bit mode
 386   1         - Right justified. No shifting applied
 387   1         - Perform and Accumulate 1 conversion
 388   1         ***********************************************************************/
 389   1        SFRPAGE = 0x00;
 390   1        ADC0CN1 = ADC0CN1_ADBITS__10_BIT | ADC0CN1_ADSJST__RIGHT_NO_SHIFT
 391   1            | ADC0CN1_ADRPT__ACC_1;
 392   1        // [ADC0CN1 - ADC0 Control 1]$
 393   1      
 394   1        // $[ADC0MX - ADC0 Multiplexer Selection]
 395   1        /***********************************************************************
 396   1         - Select ADC0.0
 397   1         ***********************************************************************/
 398   1        ADC0MX = ADC0MX_ADC0MX__ADC0P0;
 399   1        // [ADC0MX - ADC0 Multiplexer Selection]$
 400   1      
 401   1        // $[ADC0CF2 - ADC0 Power Control]
 402   1        /***********************************************************************
 403   1         - The ADC0 ground reference is internal ground
 404   1         - Selects 1.8V from internal fast reference as the ADC0 voltage
 405   1         reference
 406   1         - Power Up Delay Time = 0x0F
 407   1         ***********************************************************************/
 408   1        ADC0CF2 = ADC0CF2_GNDSL__GND_PIN | ADC0CF2_REFSL__1V8
 409   1            | (0x0F << ADC0CF2_ADPWR__SHIFT);
 410   1        // [ADC0CF2 - ADC0 Power Control]$
 411   1      
 412   1        // $[ADC0CF1 - ADC0 Configuration]
 413   1        /***********************************************************************
 414   1         - Disable external voltage reference for the ADC
 415   1         - Conversion Tracking Time = 0x0B
 416   1         ***********************************************************************/
 417   1        ADC0CF1 = ADC0CF1_RPCE__DISABLED | (0x0B << ADC0CF1_ADTK__SHIFT);
 418   1        // [ADC0CF1 - ADC0 Configuration]$
 419   1      
 420   1        // $[ADC0ASAL - ADC0 Autoscan Start Address Low Byte]
 421   1        // [ADC0ASAL - ADC0 Autoscan Start Address Low Byte]$
 422   1      
 423   1        // $[ADC0GTH - ADC0 Greater-Than High Byte]
 424   1        // [ADC0GTH - ADC0 Greater-Than High Byte]$
 425   1      
 426   1        // $[ADC0GTL - ADC0 Greater-Than Low Byte]
 427   1        // [ADC0GTL - ADC0 Greater-Than Low Byte]$
 428   1      
 429   1        // $[ADC0LTH - ADC0 Less-Than High Byte]
 430   1        // [ADC0LTH - ADC0 Less-Than High Byte]$
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 8   

 431   1      
 432   1        // $[ADC0LTL - ADC0 Less-Than Low Byte]
 433   1        // [ADC0LTL - ADC0 Less-Than Low Byte]$
 434   1      
 435   1        // $[ADC0ASCF - ADC0 Autoscan Configuration]
 436   1        // [ADC0ASCF - ADC0 Autoscan Configuration]$
 437   1      
 438   1        // $[ADC0CN0 - ADC0 Control 0]
 439   1        /***********************************************************************
 440   1         - Enable ADC0 
 441   1         - The on-chip gain is 0.5
 442   1         ***********************************************************************/
 443   1        ADC0CN0 &= ~ADC0CN0_ADGN__FMASK;
 444   1        ADC0CN0 |= ADC0CN0_ADEN__ENABLED | ADC0CN0_ADGN__GAIN_0P5;
 445   1        // [ADC0CN0 - ADC0 Control 0]$
 446   1      
 447   1      }
 448          
 449          extern void
 450          PWM_0_enter_DefaultMode_from_RESET (void)
 451          {
 452   1        // $[Stop PWM]
 453   1        SFRPAGE = 0x10;
 454   1        PWMCFG1 &= ~(PWMCFG1_PWMEN__BMASK);
 455   1        // [Stop PWM]$
 456   1      
 457   1        // $[PWMCKDIV - PWMCKDIV]
 458   1        // [PWMCKDIV - PWMCKDIV]$
 459   1      
 460   1        // $[PWMCFG0 - PWM Configuration 0]
 461   1        /***********************************************************************
 462   1         - Enable clock to the PWM module
 463   1         - PWM will operate in Edge-aligned mode
 464   1         - Channel 0, Channel 1, and Channel 2 will be synchronously updated
 465   1         - PWM will continue running on breakpoints in debug mode
 466   1         - Rising edge on the enabled external trigger will start PWM counter
 467   1         - Disable Kill0 signal to halt the PWM
 468   1         ***********************************************************************/
 469   1        PWMCFG0 = PWMCFG0_PWMCLKEN__ENABLE | PWMCFG0_PWMMODE__EDGE
 470   1            | PWMCFG0_SYNCUPD__CH0CH1CH2 | PWMCFG0_DBGSTLEN__DISABLE
 471   1            | PWMCFG0_TRGESEL__REDGE | PWMCFG0_KILL0EN__DISABLE;
 472   1        // [PWMCFG0 - PWM Configuration 0]$
 473   1      
 474   1        // $[PWMCFG1 - PWM Configuration 1]
 475   1        // [PWMCFG1 - PWM Configuration 1]$
 476   1      
 477   1        // $[PWMCFG2 - PWM Configuration 2]
 478   1        /***********************************************************************
 479   1         - Do nothing
 480   1         - PWM triggered by software setting PWMEN
 481   1         - Enable PWM Channel 0
 482   1         - Enable PWM Channel 1
 483   1         - Enable PWM Channel 2
 484   1         ***********************************************************************/
 485   1        PWMCFG2 = PWMCFG2_TRGSEL__DISABLE | PWMCFG2_CH0EN__ENABLE
 486   1            | PWMCFG2_CH1EN__ENABLE | PWMCFG2_CH2EN__ENABLE | PWMCFG2_CNTRZERO__ZERO;
 487   1        // [PWMCFG2 - PWM Configuration 2]$
 488   1      
 489   1        // $[PWMCFG3 - PWMCFG3]
 490   1        // [PWMCFG3 - PWMCFG3]$
 491   1      
 492   1        // $[PWML - PWML]
 493   1        // [PWML - PWML]$
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 9   

 494   1      
 495   1        // $[PWMH - PWMH]
 496   1        // [PWMH - PWMH]$
 497   1      
 498   1        // $[PWMLIML - PWMLIML]
 499   1        /***********************************************************************
 500   1         - PWM Counter Limit LSB = 0xFF
 501   1         ***********************************************************************/
 502   1        PWMLIML = (0xFF << PWMLIML_PWMLIML__SHIFT);
 503   1        // [PWMLIML - PWMLIML]$
 504   1      
 505   1        // $[PWMLIMH - PWMLIMH]
 506   1        /***********************************************************************
 507   1         - PWM Counter Limit MSB = 0xFF
 508   1         ***********************************************************************/
 509   1        PWMLIMH = (0xFF << PWMLIMH_PWMLIMH__SHIFT);
 510   1        // [PWMLIMH - PWMLIMH]$
 511   1      
 512   1        // $[PWMDTIPLIM - PWMDTIPLIM]
 513   1        // [PWMDTIPLIM - PWMDTIPLIM]$
 514   1      
 515   1        // $[PWMDTINLIM - PWMDTINLIM]
 516   1        // [PWMDTINLIM - PWMDTINLIM]$
 517   1      
 518   1        // $[PWMIE - PWMIE]
 519   1        // [PWMIE - PWMIE]$
 520   1      
 521   1        // $[PWM On]
 522   1        PWMCFG1 |= PWMCFG1_PWMEN__ENABLE;
 523   1        // [PWM On]$
 524   1      
 525   1      }
 526          
 527          extern void
 528          PWMCH_0_enter_DefaultMode_from_RESET (void)
 529          {
 530   1        // $[PWMCPL0 - Ch0 Compare Value LSB]
 531   1        // [PWMCPL0 - Ch0 Compare Value LSB]$
 532   1      
 533   1        // $[PWMCPH0 - Ch0 Compare Value MSB]
 534   1        // [PWMCPH0 - Ch0 Compare Value MSB]$
 535   1      
 536   1        // $[PWMCPUDL0 - Ch0 Compare Value Update LSB]
 537   1        // [PWMCPUDL0 - Ch0 Compare Value Update LSB]$
 538   1      
 539   1        // $[PWMCPUDH0 - Ch0 Compare Value Update MSB]
 540   1        // [PWMCPUDH0 - Ch0 Compare Value Update MSB]$
 541   1      
 542   1      }
 543          
 544          extern void
 545          PWMCH_1_enter_DefaultMode_from_RESET (void)
 546          {
 547   1        // $[PWMCPL1 - Ch1 Compare Value LSB]
 548   1        // [PWMCPL1 - Ch1 Compare Value LSB]$
 549   1      
 550   1        // $[PWMCPH1 - Ch1 Compare Value MSB]
 551   1        // [PWMCPH1 - Ch1 Compare Value MSB]$
 552   1      
 553   1        // $[PWMCPUDL1 - Ch1 Compare Value Update LSB]
 554   1        // [PWMCPUDL1 - Ch1 Compare Value Update LSB]$
 555   1      
 556   1        // $[PWMCPUDH1 - Ch1 Compare Value Update MSB]
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 10  

 557   1        // [PWMCPUDH1 - Ch1 Compare Value Update MSB]$
 558   1      
 559   1      }
 560          
 561          extern void
 562          PWMCH_2_enter_DefaultMode_from_RESET (void)
 563          {
 564   1        // $[PWMCPL2 - Ch2 Compare Value LSB]
 565   1        // [PWMCPL2 - Ch2 Compare Value LSB]$
 566   1      
 567   1        // $[PWMCPH2 - Ch2 Compare Value MSB]
 568   1        // [PWMCPH2 - Ch2 Compare Value MSB]$
 569   1      
 570   1        // $[PWMCPUDL2 - Ch2 Compare Value Update LSB]
 571   1        // [PWMCPUDL2 - Ch2 Compare Value Update LSB]$
 572   1      
 573   1        // $[PWMCPUDH2 - Ch2 Compare Value Update MSB]
 574   1        // [PWMCPUDH2 - Ch2 Compare Value Update MSB]$
 575   1      
 576   1      }
 577          
 578          extern void
 579          TIMER16_2_enter_DefaultMode_from_RESET (void)
 580          {
 581   1        // $[Timer Initialization]
 582   1        // Save Timer Configuration
 583   1        uint8_t TMR2CN0_TR2_save;
 584   1        TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
 585   1        // Stop Timer
 586   1        TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);
 587   1        // [Timer Initialization]$
 588   1      
 589   1        // $[TMR2CN1 - Timer 2 Control 1]
 590   1        // [TMR2CN1 - Timer 2 Control 1]$
 591   1      
 592   1        // $[TMR2CN0 - Timer 2 Control]
 593   1        // [TMR2CN0 - Timer 2 Control]$
 594   1      
 595   1        // $[TMR2H - Timer 2 High Byte]
 596   1        // [TMR2H - Timer 2 High Byte]$
 597   1      
 598   1        // $[TMR2L - Timer 2 Low Byte]
 599   1        // [TMR2L - Timer 2 Low Byte]$
 600   1      
 601   1        // $[TMR2RLH - Timer 2 Reload High Byte]
 602   1        /***********************************************************************
 603   1         - Timer 2 Reload High Byte = 0x60
 604   1         ***********************************************************************/
 605   1        TMR2RLH = (0x60 << TMR2RLH_TMR2RLH__SHIFT);
 606   1        // [TMR2RLH - Timer 2 Reload High Byte]$
 607   1      
 608   1        // $[TMR2RLL - Timer 2 Reload Low Byte]
 609   1        /***********************************************************************
 610   1         - Timer 2 Reload Low Byte = 0x7F
 611   1         ***********************************************************************/
 612   1        TMR2RLL = (0x7F << TMR2RLL_TMR2RLL__SHIFT);
 613   1        // [TMR2RLL - Timer 2 Reload Low Byte]$
 614   1      
 615   1        // $[TMR2CN0]
 616   1        /***********************************************************************
 617   1         - Start Timer 2 running
 618   1         ***********************************************************************/
 619   1        TMR2CN0 |= TMR2CN0_TR2__RUN;
C51 COMPILER V9.60.0.0   INITDEVICE                                                        10/20/2025 19:56:58 PAGE 11  

 620   1        // [TMR2CN0]$
 621   1      
 622   1        // $[Timer Restoration]
 623   1        // Restore Timer Configuration
 624   1        TMR2CN0 |= TMR2CN0_TR2_save;
 625   1        // [Timer Restoration]$
 626   1      
 627   1      }
 628          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    258    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
