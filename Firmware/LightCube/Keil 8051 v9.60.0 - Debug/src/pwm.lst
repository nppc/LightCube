C51 COMPILER V9.60.0.0   PWM                                                               10/19/2025 22:03:42 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\src\pwm.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5_2\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\src\tennp\g
                    -it\LightCube\Firmware\LightCube\src\pwm.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZ
                    -E(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/SiliconLabs/SimplicityStudio/v5_2/developer/sdks/8051/
                    -v4.3.1//Device/EFM8BB50/inc;C:/SiliconLabs/SimplicityStudio/v5_2/developer/sdks/8051/v4.3.1//Device/shared/si8051Base) P
                    -RINT(.\src\pwm.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\pwm.OBJ)

line level    source

   1          /*
   2           * pwm.c
   3           *
   4           *  Created on: Oct 5, 2025
   5           *      Author: Pavel
   6           */
   7          
   8          #include "main.h"
   9          #include "pwm.h"
  10          
  11          uint16_t pwm_fade_step[NUM_LEDS];      // Calculated step per channel
  12          //bit fading_active = 0;                     // Flag to indicate fading is in progress
  13          
  14          
  15          void start_poweroff_sequence(void) {
  16   1          uint8_t i;
  17   1          for (i = 0; i < NUM_LEDS; i++) {
  18   2              uint16_t current_pwm = pwm_channels[i].u16;  // Read current value
  19   2              pwm_fade_step[i] = current_pwm / FADE_STEPS;
  20   2              if (pwm_fade_step[i] == 0 && current_pwm > 0) {
  21   3                  pwm_fade_step[i] = 1;  // Ensure minimum step
  22   3              }
  23   2          }
  24   1      }
  25          
  26          
  27          bit process_fadeout(void) {
  28   1      
  29   1          bit all_zero = 1;
  30   1          uint8_t i;
  31   1          for (i = 0; i < NUM_LEDS; i++) {
  32   2              uint16_t current_pwm = pwm_channels[i].u16;  // Read current value
  33   2      
  34   2              if (current_pwm > 0) {
  35   3                  uint16_t new_pwm = (current_pwm > pwm_fade_step[i])
  36   3                                     ? (current_pwm - pwm_fade_step[i])
  37   3                                     : 0;
  38   3                  set_pwm(i, new_pwm, 0);  // Update via setter
  39   3              }
  40   2      
  41   2              if (pwm_channels[i].u16 > 0) {
  42   3                  all_zero = 0;
  43   3              }
  44   2          }
  45   1      
  46   1          if (all_zero) {
  47   2              return 1;  // Fade-out complete
  48   2          }
  49   1      
  50   1          return 0;  // Still fading
  51   1      }

C51 COMPILER V9.60.0.0   PWM                                                               10/19/2025 22:03:42 PAGE 2   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    205    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
