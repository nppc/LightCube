C51 COMPILER V9.60.0.0   CANDLE                                                            11/17/2025 16:23:11 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CANDLE
OBJECT MODULE PLACED IN .\src\candle.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\src\tennp\git
                    -\LightCube\Firmware\LightCube\src\candle.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMI
                    -ZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v
                    -4.3.1//Device/EFM8BB50/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.3.1//Device/shared/si8051Base) PRIN
                    -T(.\src\candle.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\candle.OBJ)

line level    source

   1          #include "main.h"
   2          #define NUM_LEDS           4
   3          #define BRIGHTNESS_LEVEL   75
   4          #define STARTUP_STEP       1
   5          #define FLICKER_PROB       8
   6          #define GLOW_EVENT_PROB    16 // no affect on brightness range
   7          #define GLOW_RANGE         25
   8          
   9          /* Ensure brightness curve index never exceeds MAX_STEPS */
  10          #if (BRIGHTNESS_LEVEL + GLOW_RANGE + 8) >= MAX_STEPS
                #error "Configuration error: BRIGHTNESS_LEVEL + GLOW_RANGE + max flicker offset exceeds MAX_STEPS"
              #endif
  13          
  14          
  15          typedef struct {
  16              unsigned char current_level;
  17              unsigned char flicker_timer;
  18              char flicker_delta;
  19              char glow_timer;   /* signed: >0 up, <0 down, 0 = idle */
  20          } LEDState;
  21          
  22          static LEDState leds[NUM_LEDS];
  23          static bit startup_done;
  24          
  25          void candle_init(void)
  26          {
  27   1          unsigned char i;
  28   1          for (i = 0; i < NUM_LEDS; ++i) {
  29   2              leds[i].current_level = 0;
  30   2              leds[i].flicker_timer = 0;
  31   2              leds[i].flicker_delta = 0;
  32   2              leds[i].glow_timer = 0;
  33   2              set_pwm(i, 0, 1);
  34   2          }
  35   1          startup_done = 0;
  36   1      }
  37          
  38          void candle_tick(void)
  39          {
  40   1          unsigned char i, idx;
  41   1          for (i = 0; i < NUM_LEDS; ++i) {
  42   2              LEDState *led = &leds[i];
  43   2              char offset = 0;
  44   2      
  45   2              if (!startup_done) {
  46   3                  if (led->current_level < BRIGHTNESS_LEVEL) {
  47   4                      led->current_level += STARTUP_STEP;
  48   4                      if (led->current_level > BRIGHTNESS_LEVEL)
  49   4                          led->current_level = BRIGHTNESS_LEVEL;
  50   4                  }
  51   3              } else if (led->flicker_timer) {
  52   3                  led->flicker_timer--;
C51 COMPILER V9.60.0.0   CANDLE                                                            11/17/2025 16:23:11 PAGE 2   

  53   3                  offset = (led->flicker_timer < led->flicker_delta) ?
  54   3                              led->flicker_timer :
  55   3                              (2 * led->flicker_delta - led->flicker_timer);
  56   3              } else if ((rand() & 0xFF) < FLICKER_PROB) {
  57   3                  led->flicker_delta = (char)((rand() & 7) + 1);
  58   3                  led->flicker_timer = (unsigned char)(led->flicker_delta << 1);
  59   3              } else if (led->glow_timer) {
  60   3                  if (led->glow_timer > 0) {
  61   4                      led->glow_timer--;
  62   4                      if (led->current_level < BRIGHTNESS_LEVEL + GLOW_RANGE)
  63   4                          led->current_level++;
  64   4                      else
  65   4                          led->glow_timer = -(led->glow_timer); /* flip direction */
  66   4                  } else {
  67   4                      led->glow_timer++;
  68   4                      if (led->current_level > BRIGHTNESS_LEVEL - GLOW_RANGE)
  69   4                          led->current_level--;
  70   4                      else
  71   4                          led->glow_timer = -(led->glow_timer); /* flip direction */
  72   4                  }
  73   3              } else if ((rand() & 0xFF) < GLOW_EVENT_PROB) {
  74   3                  /* pick direction by sign */
  75   3                  char t = (char)(30 + (rand() & 0x1F));
  76   3                  led->glow_timer = (rand() & 1) ? t : -t;
  77   3              }
  78   2      
  79   2              idx = led->current_level + offset;
  80   2              if (idx >= MAX_STEPS) idx = MAX_STEPS - 1;
  81   2              set_pwm(i, brightness_curve[idx], 1);
  82   2          }
  83   1      
  84   1          if (!startup_done) {
  85   2              startup_done = 1;
  86   2              for (i = 0; i < NUM_LEDS; ++i)
  87   2                  if (leds[i].current_level < BRIGHTNESS_LEVEL)
  88   2                      startup_done = 0;
  89   2          }
  90   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    571    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
